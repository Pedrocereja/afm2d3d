include "FETOOLS.edp"
include "REDSYS.edp"
include "ARRAYS.edp"

load "gmsh"
load "iovtk"
load "medit"
load "msh3"

macro DIM 3 // /* 2=2D , 3=3D */

bool bcheckboundaries=false; // set to "true" to check the boundary regions
bool bplotregion=false; // set to "true" to plot the physical regions
bool bplotcoils=false; // set to "true" to plot the mesh associated with each coil (3D) or the current density associated to each coil (2D)
bool bperiodicity=true; // set to "true" to apply periodicity condition
bool bcheckperiodicitydofs = false; // set to "true" to check the periodicity dofs
bool bchecksupport=false;
bool bcomputeinterp=1;

real Itot = 474.67; // total current in coils section (A) (in the considered configuration, phase U (or 0) has null current, and phase V (or 1) and W (or 2) carry the same current (up to the sign))
real Jimp = 7.8e5; // Imposed current density
real I1=Itot;
//real I2=-I1;

real Br = 1.17; // remanent induction of the magnets (T)

real mu0 = 4*pi*1e-7; //vacuum permeability
real nu0 = 1./mu0; // vacuum reluctivity
real muiron = 1000*mu0; // iron permeablitiy
real nuiron = 1./muiron; // iron reluctivity
real mupm = 1.05*mu0; // permanent magnet permeability
real nupm = 1./mupm; // permanent magnet reluctivity
real mucoil = mu0; // coil permeability
real nucoil = 1./mucoil; // coil reluctivity

IFMACRO(DIM,2)
	include "afm2D.def"
	include "afm2D.init"
	include "../include/MACROS2D.edp"
	// directory where the results should be saved
	string DIRres="results/2D/";

	mesh Th = gmshload("afm2D2.msh");
	plot(Th,wait=1);

	bool bplanestress=0;// true if plane stress, false if plane strain

	mesh Thper=movemesh(Th,[x+2*(3.14*rm)/p,y]); // Malha perpendicular à original (lado direito)
	plot(Th,Thper,wait=1);

	real[string] signcurrent;
	signcurrent["plus"]=1;
	signcurrent["minus"]=-1;

	macro currentdensity(A,plus,bplot)
	/* macro currentdensity(A,plus,bplot) compute current density field for phase "A plus"*/
	ThP0vec1 J#plus#A;
	{
	real surf=int2d(Th,phase#plus#[A])(1);
	J#plus#A=regphase#plus#[A]*signcurrent[Stringification(plus)]/surf;
	/*J#plus#A=regphase#plus#[A]*signcurrent[Stringification(plus)];*/
	if(bplot) plot(J#plus#A,wait=1,fill=1,value=1,cmm="J"+Stringification(plus)+Stringification(A)+" (A/m2)");
	}

	// surface regions
	int nbnd=4;
	int[int][int] bnd(nbnd);
	string[int] bndname(nbnd);
	int ibnd=0;
	//symmetry plane (mid plane of the stator, perpendicular to the axis of the machine)
	bnd[ibnd] = [ESTATORL1];
	bndname[ibnd]="szmin";
	// external plane boundary pependicular to the machine axis
	ibnd++;
	bnd[ibnd] = [CAMSARS];
	//bnd[ibnd] = [ROTORL43];
	bndname[ibnd]="szmax";
	// periodicity planes (parallel to and containing the axis of the machine)
	ibnd++;
	bnd[ibnd] = [ESTATORL2,WML16,GAP1L23,GAP23L35,ROTORL41,CAMSARLD];
	//bnd[ibnd] = [ESTATORL2,WML16,GAP1L23,GAP23L35,ROTORL41];
	bndname[ibnd]="sperio1";
	ibnd++;
	bnd[ibnd] = [ESTATORL3,VPL10,GAP1L24,GAP21L30,ROTORL42,CAMSARLE];
	//bnd[ibnd] = [ESTATORL3,VPL10,GAP1L24,GAP21L30,ROTORL42];
	bndname[ibnd]="sperio2";

	int[string] ibndname; //to get the boundary index by name
	for(int i=0;i<nbnd;++i) ibndname[bndname[i]]=i;

	// boundary Dirichlet
	int[int] sBn0 = [bnd[ibndname["szmin"]]];
	sBn0=[sBn0,bnd[ibndname["szmax"]]];

	//volume regions
	int[int][int] rotor(1), magnet(2),stator(1),air(1);
	rotor[0]=[ROTOR];
	magnet[0]=[IMA1];magnet[1]=[IMA2];
	stator[0]=[ESTATOR];

	air[0]=[GAP1,GAP21,GAP22,GAP23,CAMSAR]; //2D mesh
	//air[0]=[GAP1,GAP21,GAP22,GAP23]; //2D mesh

	int[int][int] phaseplus(3),coil(6);
	//phaseplus[0]=[UPLUS];
	//phaseplus[1]=[VPLUS];
	//phaseplus[2]=[WPLUS];
	phaseplus[0]=[UPLUS];
	phaseplus[1]=[VPLUS];
	phaseplus[2]=[WPLUS];

	int[int][int] phaseminus(3);
	//phaseminus[0]=[UMINUS];
	//phaseminus[1]=[VMINUS];
	//phaseminus[2]=[WMINUS];
	phaseminus[0]=[UMINUS];
	phaseminus[1]=[VMINUS];
	phaseminus[2]=[WMINUS];

	coil[0]=[UPLUS];
	coil[1]=[VPLUS];
	coil[2]=[WPLUS];
	coil[3]=[UMINUS];
	coil[4]=[VMINUS];
	coil[5]=[WMINUS];

	macro vecBr [0,Br*(regmagnet[0]-regmagnet[1])] //

ENDIFMACRO

IFMACRO(DIM,3)
	include "afm3D.def"
	include "afm3D.init"
	include "../include/MACROS3D.edp"
	// directory where the results should be saved
	string DIRres="results/3D/";

	mesh3 Th = gmshload3("afm3Dv2.msh");
	plot(Th,wait=1);

	mesh Th2 = gmshload("afm2D2.msh");
	plot(Th2,wait=1);

	meshS Th23d = movemesh23(Th2, transfo=[x,y,0]);


	real ppi = 3.14;
	real tr = 2*(ppi*rm)/p;			// Comprimento do rotor no qual está colado o imã
	meshS Th23 = movemesh23(Th2, transfo=[0,x-tr/2,y]);
	Th23 = movemeshS(Th23, transfo=[-rm*sin(y/rm),rm*cos(y/rm),z]);
	plot(Th23,wait=1);
	plot(Th2,Th23,Th,wait=1);


	bool bplanestress=0;//false for 3D case

	real angle=pi/7;
	mesh3 Thper=movemesh(Th,[cos(angle)*x-sin(angle)*y,sin(angle)*x+cos(angle)*y,z]);
	plot(Th,Thper,wait=1);

	macro currentdensity(A,plus,bplot)
	/* macro currentdensity(A,plus,bplot) compute current density field for phase "A plus"*/
	ThP0vec1 vec(J#plus#A);
	{
	mesh3 Thtrunc = trunc(Th,reg#phase#plus[A]>0.5);
	if(bplot) plot(Thtrunc,wait=1,cmm="mesh for current density phase "+Stringification(A)+Stringification(plus));
	fespace ThtruncP1scal(Thtrunc,P1);
	ThtruncP1scal v, vv;
	solve laplace(v,vv)=int3d(Thtrunc)(grad(v)'*grad(vv))
	+ on(bnd[ibndname["sphase"+Stringification(plus)+"in"+Stringification(A)]],v=0)
	+ on(bnd[ibndname["sphase"+Stringification(plus)+"out"+Stringification(A)]],v=1);
	vec(J#plus#A)=[reg#phase#plus[A]*dx(v),reg#phase#plus[A]*dy(v),reg#phase#plus[A]*dz(v)];
	varf vonin(v,vv)=on(bnd[ibndname["sphase"+Stringification(plus)+"out"+Stringification(A)]],v=1);
	ThtruncP1scal onin;
	onin[]=vonin(0,ThtruncP1scal,tgv=1);
	real I=int3d(Thtrunc)(vec(J#plus#A)'*[dx(onin),dy(onin),dz(onin)]); /*compute total current in*/
	J#plus#A#x[]=J#plus#A#x[]/I; /*nomalized current density*/
	savevtk(DIRres+"J"+Stringification(plus)+Stringification(A)+".vtu",Th,vec(J#plus#A),order=order0,dataname="J"+Stringification(plus)+Stringification(A));
	fespace ThtruncP0vec(Thtrunc,[P0,P0,P0]);
	ThtruncP0vec vec(jj);
	vec(jj)=vec(J#plus#A);
	savevtk(DIRres+"jj"+Stringification(plus)+Stringification(A)+".vtu",Thtrunc,vec(jj),order=order0,dataname="jj"+Stringification(plus)+Stringification(A));
	}
	// EOM
	// surface regions
	int nbnd=18;
	int[int][int] bnd(nbnd);
	string[int] bndname(nbnd);
	int ibnd=0;

	// internal radius of the machine
	//bnd[ibnd] = [20084,20085,20086,20087,20088,20089,20090,20091,20092,20093,20219,20220,20221,20222,20223,20224,20225,20226,20227,20228,20311,20312,20313,20314,20315,20316,20317,20318,20319,20320,20426,20427,20428,20429,20430,20431,20432,20433,20434,20435];
	bnd[ibnd] = [20776,20777,20778,20779,20780,20781,20782,20783,20784,20785,20807,20808,20809,20810,20811,20812,20813,20814,20815,20816,20838,20839,20840,20841,20842,20843,20844,20845,20846,20847,20869,20870,20871,20872,20873,20874,20875,20876,20877,20878,20900,20901,20902,20903,20904,20905,20906,20907,20908,20909];
	bndname[ibnd]="srint";
	// external radius of the machine
	ibnd++;
	//bnd[ibnd] = [20146,20147,20148,20149,20150,20151,20152,20153,20154,20155,20260,20261,20262,20263,20264,20265,20266,20267,20268,20269,20352,20353,20354,20355,20356,20357,20358,20359,20360,20361,20457,20458,20459,20460,20461,20462,20463,20464,20465,20466];
	bnd[ibnd] = [20982,20983,20984,20985,20986,20987,20988,20989,20990,20991,21013,21014,21015,21016,21017,21018,21019,21020,21021,21022,21044,21045,21046,21047,21048,21049,21050,21051,21052,21053,21075,21076,21077,21078,21079,21080,21081,21082,21083,21084,21106,21107,21108,21109,21110,21111,21112,21113,21114,21115];
	bndname[ibnd]="srext";
	//symmetry plane (mid plane of the stator, perpendicular to the axis of the machine)
	ibnd++;
	//bnd[ibnd] = [20021,20022,20023,20024,20025,20026,20027,20028,20029,20030,20126,20127,20128,20129,20130,20131,20132,20133,20134,20135,20188,20189,20190,20191,20192,20193,20194,20195,20196,20197];
	bnd[ibnd] = [20021,20022,20023,20024,20025,20026,20027,20028,20029,20030,20126,20127,20128,20129,20130,20131,20132,20133,20134,20135,20188,20189,20190,20191,20192,20193,20194,20195,20196,20197,20930,20931,20932,20933,20934,20935,20936,20937,20938,20939,20755,20756,20757,20758,20759,20760,20761,20762,20763,20764];
	bndname[ibnd]="szmin";
	// external plane boundary pependicular to the machine axis
	ibnd++;
	//bnd[ibnd] = [20436,20437,20438,20439,20440,20441,20442,20443,20444,20445,20467,20468,20469,20470,20471,20472,20473,20474,20475,20476,20488,20489,20490,20491,20492,20493,20494,20495,20496,20497];
	bnd[ibnd] = [20693,20694,20695,20696,20697,20698,20699,20700,20701,20702,20662,20663,20664,20665,20666,20667,20668,20669,20670,20671,20631,20632,20633,20634,20635,20636,20637,20638,20639,20640,21085,21086,21087,21088,21089,21090,21091,21092,21093,21094,20910,20911,20912,20913,20914,20915,20916,20917,20918,20919];
	bndname[ibnd]="szmax";
	// periodicity planes (parallel to and containing the axis of the machine)
	ibnd++;
	//bnd[ibnd] = [20041,20073,20094,20105,20156,20167,20208,20249,20290,20331,20372,20393,20415,20446,20477];
	bnd[ibnd] = [20950,20971,21002,21033,21064,21095,20041,20073,20094,20105,20156,20167,20208,20249,20290,20331,20372,20393,20415,20446,20477,20600,20589,20578,20712,20682,20651,20724,20765,20796,20827,20858,20889];
	bndname[ibnd]="sperio1";
	ibnd++;
	//bnd[ibnd] = [20042,20083,20104,20115,20166,20177,20218,20259,20300,20341,20382,20403,20425,20456,20487];
	bnd[ibnd] = [20042,20083,20104,20115,20166,20177,20218,20259,20300,20341,20382,20403,20425,20456,20487,20960,20981,21012,21043,21074,21105,20588,20599,20610,20661,20692,20722,20734,20775,20806,20837,20868,20899];
	bndname[ibnd]="sperio2";

	//in and out surfaces for each phase winding (plus and minus)
	int[int][int] mpio(4*3); //minus/plus in/out boundary region indexes for the 3 phases
	int ip=0;
	mpio[4*ip+0]=[20133];mpio[4*ip+1]=[20195];mpio[4*ip+2]=[20190];mpio[4*ip+3]=[20128];
	ip++;
	mpio[4*ip+0]=[20126,20127];mpio[4*ip+1]=[20188,20189];mpio[4*ip+2]=[20193,20194];mpio[4*ip+3]=[20131,20132];
	ip++;
	mpio[4*ip+0]=[20129,20130];mpio[4*ip+1]=[20191,20192];mpio[4*ip+2]=[20196,20197];mpio[4*ip+3]=[20134,20135];

	for(int ip=0; ip<3;++ip){
		ibnd++; bnd[ibnd] = [mpio[4*ip+0]]; bndname[ibnd]="sphaseminusin"+ip;
		ibnd++; bnd[ibnd] = [mpio[4*ip+1]]; bndname[ibnd]="sphaseminusout"+ip;
		ibnd++; bnd[ibnd] = [mpio[4*ip+2]]; bndname[ibnd]="sphaseplusin"+ip;
		ibnd++; bnd[ibnd] = [mpio[4*ip+3]]; bndname[ibnd]="sphaseplusout"+ip;
	}

	int[string] ibndname; //to get the boundary index by name
	for(int i=0;i<nbnd;++i) ibndname[bndname[i]]=i;

	// boundary Dirichlet
	int[int] sBn0=bnd[ibndname["srint"]];
	sBn0=[sBn0,bnd[ibndname["srext"]]];
	sBn0=[sBn0,bnd[ibndname["szmin"]]];
	sBn0=[sBn0,bnd[ibndname["szmax"]]];

	int[int] sBn02 = bnd[ibndname["srint"]];
	//volume regions
	int[int][int] rotor(1), magnet(2),stator(1),air(1);
	rotor[0]=[ROTOR];
	magnet[0]=[IMA1];magnet[1]=[IMA2];
	stator[0]=[ESTATOR];

	air[0]=[ARARCRI,ARARCRE,AR1,AR31,AR32,AR21,AR22,AR23,ARSUP,ARRI1,ARRE1]; //3D mesh

	int[int][int] phaseplus(3);
	phaseplus[0]=[FASEUP];
	phaseplus[1]=[FASEVP];
	phaseplus[2]=[FASEWP];

	int[int][int] phaseminus(3);
	phaseminus[0]=[FASEUM];
	phaseminus[1]=[FASEVM];
	phaseminus[2]=[FASEWM];

	int[int][int] coil(6);/*
	coil[0]=[UPLUS];
	coil[1]=[VPLUS];
	coil[2]=[WPLUS];
	coil[3]=[UMINUS];
	coil[4]=[VMINUS];
	coil[5]=[WMINUS];*/
	coil[0] = [FASEUP];
	coil[1] = [FASEVP];
	coil[2] = [FASEWP];
	coil[3] = [FASEUM];
	coil[4] = [FASEVM];
	coil[5] = [FASEWM];

	macro vecBr [0,0,Br*(regmagnet[0]-regmagnet[1])] //
ENDIFMACRO

real[int] usupportcoef=vecff(1,1,1);
real[int] udircoef=vecff(1,1,1);

int[int] order0=[0]; // for cell based fields (savevtk interpolates at the center of the tetrahedron)
int[int] order1=[1]; // for node based fields (savevtk interpolates at nodes)

FEspace(Th,fetype1,vec1)
FEspace(Th,P1,scal)
FEspace(Th,P1,vec);

FEspace(Th,P0,scal)
FEspace(Th,P0,vec1)
FEspace(Th,P0,vec2)
FEspace(Th,P0,tens2);
FEspace(Th,P0,tens22);

FEspace(Thper,P1,scal)
FEspace(Thper,fetype1,vec1);
FEspace(Thper,P1,vec);


if(bcheckboundaries)
	for(int i=0;i<nbnd;++i)
	{
	varf vonbnd(a,aa)=on(bnd[i],a=1);
	ThP1scal bndP1scal;
	bndP1scal[] = vonbnd(0,ThP1scal, tgv=1);
	plot(bndP1scal,fill=1,value=1,wait=1,cmm="boundary "+bndname[i]);
	}

SetRegion(Th,rotor,bplotregion);
SetRegion(Th,magnet,bplotregion);
SetRegion(Th,stator,bplotregion);
SetRegion(Th,air,bplotregion);

SetRegion(Th,phaseplus,bplotregion);
SetRegion(Th,phaseminus,bplotregion);
SetRegion(Th,coil,bplotregion);

ThP0scal lambda,mu; //Lame coefficients (elastic properties of materials)
ThP1vec vec(u),vec(uu),vec(f),vec(udir);// vector fiels for the displacement, the force density ...
ThP0tens2 tens2(epsilon),tens2(sigma1); //elastic strain and stress
ThP0tens2 tens2(tm0); // Maxwell stress tensor without magnetostriction
ThP0tens2 tens2(tm1); // Maxwell stress tensor with constant material line circulation of M
ThP0tens2 tens2(tm2); // Maxwell stress tensor with constant material surface flux of M
ThP0tens2 tens2(tm3); // Maxwell stress tensor with constant magnetic moment

ThP0tens22 tens22(C); //stiffness tensor

ThP0vec2 vec(Br);
vec2(Br) = vecBr;

ThP0scal nu = nuiron*(regstator[0]+regrotor[0])+nupm*(regmagnet[0]+regmagnet[1])+nu0*regair[0]
              +nucoil*(regphaseplus[0]+regphaseplus[1]+regphaseplus[2]
                     + regphaseminus[0]+regphaseminus[1]+regphaseminus[2]);
mu = muiron*(regstator[0]+regrotor[0])+mupm*(regmagnet[0]+regmagnet[1])+mu0*regair[0]
              +mucoil*(regphaseplus[0]+regphaseplus[1]+regphaseplus[2]
                     + regphaseminus[0]+regphaseminus[1]+regphaseminus[2]);

currentdensity(0,minus,bplotcoils)
currentdensity(0,plus,bplotcoils)
currentdensity(1,minus,bplotcoils)
currentdensity(1,plus,bplotcoils)
currentdensity(2,minus,bplotcoils)
currentdensity(2,plus,bplotcoils)

ThP0vec1 vec1(JJ)=vec1(I1*Jplus0)+vec1(I1*Jminus0)+vec1(I1*Jplus1)+vec1(I1*Jminus1);

varf vonsperio2(u,uu)=on(bnd[ibndname["sperio2"]],u=1);
ThperP1scal onsperio2;
onsperio2[]=vonsperio2(0,ThperP1scal,tgv=1);
meshnd Thtrunc= trunc(Thper,onsperio2>0);
plot(Th,Thtrunc,wait=1,cmm="Th and trunc mesh");

FEspace(Thtrunc,fetype1,vec1)
//FEspace(Thtrunc,P1,vec);

matrix M;
cout << "compute interpolation matrix..." << endl;
cout<< "interp 1" << endl;
matrix M1=interpolate(Thtruncfetype1vec1,Thperfetype1vec1,inside=true,t=true);
real threshold=0.5;
CleanSparseMatrix(M1,threshold);
cout<< "interp 2" << endl;
matrix M2=interpolate(Thtruncfetype1vec1,Thfetype1vec1,inside=true);
CleanSparseMatrix(M2,threshold);
cout<< "end interp" << endl;
M = M1*M2;
CleanSparseMatrix(M,threshold);

real[int] fetype1vec1dircoef=vecff(1,1,1);
FlagDofBoundary(Th,fetype1,vec1,sBn0,fetype1vec1dircoef,Bn0)

SubFEspace(real,Th,fetype1,vec1,magstat)
AddDirichlet(Th,fetype1,vec1,magstat,flagdofboundaryBn0)
Thfetype1vec1 vec1(adir);
vec1firstcomp(adir)[](:)=0; //define a value for each dof invovled in the Dirichlet boundary conditions
SetDirichletValue(real,Th,fetype1,vec1,magstat,vec1firstcomp(adir)[])
SetDirichletFlag(real,Th,fetype1,vec1,magstat)

Thfetype1vec1 vec1(a);
varf magstat(vec1(a),vec1(aa)) = intnd(Th)(nu*rot2(a)'*rot2(aa))
										- intnd(Th)(vec1(JJ)'*vec1(aa))
										- intnd(Th)(nu*vec2(Br)'*rot2(aa))
										;

//varf magstat(vec1(a),vec1(aa)) = intnd(Th)(rot2(a)'*rot2(aa))
//										- intnd(Th)(vec1(JJ)'*vec1(aa))
//										- intnd(Th)(vec2(Br)'*rot2(aa))
//										;

if(1)
{

cout << "build finite element system" << endl;
matrix AA=magstat(Thfetype1vec1,Thfetype1vec1); //Matriz AA somente para a malha TH
real[int] BB=magstat(0,Thfetype1vec1);
BB = -BB;
cout << "end build finite element system" << endl; // Matriz BB somente para a malha Th - Termo fonte
//cout << "teste = " << AA << endl;

if(bperiodicity)
{
int[int,int] flagiso0(M.n,1);// be careful with tables [int,int], they must be fully initialized manually
 // the definition of "iso dofs" must be a table of type int[int,int]
 // here, there is no "iso dofs" condition, but we must define a minimum table with an "iso dofs" condition aplied to only one dof
flagiso0(:,0)=0;
flagiso0(0,0)=1;

real[int] connectcoef(M.n);
connectcoef(:)=1;

cout << "build extension matrix" << endl;
ExtensionMatrix2(real, flagiso0, M, connectcoef,Thfetype1vec1magstatdirflag,magstat)
//ExtensionMatrix(real, flagiso0, M, connectcoef,magstat)
cout << "end build extension matrix" << endl;

cout << "build restricted (iso and periodicity) and reduced (Dirichlet and support) system" << endl;
matrix Atemp1=AA*MatExtmagstat;
matrix AArest=MatExtmagstat'*Atemp1; //restricted matrix
real[int] BBrest=MatExtmagstat'*BB; //restricted RHS

real[int] restdir=MatExtmagstat'*Thfetype1vec1magstatdirflag; // restricted flag for Dirichlet condition
int[int] intrestdir(restdir.n);
for(int i=0;i<restdir.n;++i) if(abs(restdir(i))>0.5) intrestdir(i)=1; else intrestdir(i)=0; /*here node element have all the same orientation, for other type of element, even for a periodic mesh, we may note have the same orientation =>  use abs(). the abs() is also necessary when anti-periodicity is considered (connectcoef=-1)*/
/*the technique may not work for non-periodic meshes where the interpolation involves various elements...*/
real[int] restdirvalue=MatExtmagstat'*Thfetype1vec1magstatdirvalue; // restricted value for Dirichlet condition

RedSysDirichlet(real, AArest, BBrest, intrestdir, intrestdir, restdirvalue)
/*RedSysDirichlet creates the reduced system */

real[int] solper1(BBrestred.n);
set(AArestred,solver=CG);
//set(AArestred,solver=UMFPACK);

cout << " end build restricted (iso and periodicity) and reduced (Dirichlet and support) system" << endl;

cout <<"solve restricted and reduced system" << endl;
solper1=AArestred^-1*BBrestred;
cout <<"end solve restricted and reduced system" << endl;

cout <<"span restricted and reduced system solution to original system" << endl;
real[int] solper2(BBrest.n);
solper2=solper1(AArestspandof); //span the solution to the original system

real[int] tempsoldir(AArestinddirdof.n);
tempsoldir=restdirvalue(AArestinddirdof);
solper2(AArestinddirdof)=tempsoldir; // corrects the values on the Dirichlet dofs

vec1firstcomp(a)[]=MatExtmagstat*solper2; //extends the solution to the original problem
cout <<"span restricted and reduced system solution to original system" << endl;

}else{

RedSysDirichlet(real, AA, BB, Thfetype1vec1magstatdirflag, Thfetype1vec1magstatdirflag, Thfetype1vec1magstatdirvalue)
real[int] xx(AAred.n);
set(AAred,solver=CG);
//set(AAred,solver=UMFPACK);
xx=AAred^-1*BBred; //resolution of the reduced system
vec1firstcomp(a)[]=xx(AAspandof); // span the solution to the original system (be careful, the Dirichlet dofs are assigned the value of xx(0))

real[int] tempsoldir(AAinddirdof.n);
tempsoldir=Thfetype1vec1magstatdirvalue(AAinddirdof);
vec1firstcomp(a)[](AAinddirdof)=tempsoldir; // corrects the values on the Dirichlet dofs

}
}

ThP0vec2 vec2(b);
vec2(b)=rot2(a);
ThP0vec2 vec2(h),vec2(m);
vec2(h) = nu*(vec2(b)-vec2(Br));
//vec2(h) = nu*(vec2(b)-vec2(Br))*((regmagnet[0]+regmagnet[1]))+nu*vec2(b)*(regstator[0]+regrotor[0]+regair[0]+regphaseplus[0]+regphaseplus[1]+regphaseplus[2]
//                     + regphaseminus[0]+regphaseminus[1]+regphaseminus[2]);
vec2(m) = nu0*(vec2(Br));
//vec2(m) = nu0*vec2(Br)*((regmagnet[0]+regmagnet[1]))+nu0*vec2(h)*(mu-mu0)*(regstator[0]+regrotor[0]+regair[0]+regphaseplus[0]+regphaseplus[1]+regphaseplus[2]
//                   + regphaseminus[0]+regphaseminus[1]+regphaseminus[2]);
//vec2(m) = nu0*vec2(h)*(mu-u0)+nu0*vec2(Br);

IFMACRO(DIM,2)
	savevtk(DIRres+"A.vtu",Th,a,order=order1,dataname="a");
	savevtk(DIRres+"B.vtu",Th,[bx,by,0],order=order0,dataname="b");
	savevtk(DIRres+"M.vtu",Th,[hx,hy,0],order=order0,dataname="m");
	savevtk(DIRres+"H.vtu",Th,[mx,my,0],order=order0,dataname="h");

	plot(vec1(JJ),wait=1,value=1,fill=1,cmm="JJ");
	plot(vec(Br),wait=1,fill=1,value=1,cmm="Br");
	plot(vec(b),wait=1,fill=1,value=1,cmm="B");
	plot(vec(h),wait=1,fill=1,value=1,cmm="B");
	plot(vec(m),wait=1,fill=1,value=1,cmm="B");
ENDIFMACRO

IFMACRO(DIM,3)
	savevtk(DIRres+"JJ.vtu",Th,vec1(JJ),order=order0,dataname="J");
	savevtk(DIRres+"A.vtu",Th,vec(a),order=order1,dataname="a");
	savevtk(DIRres+"B.vtu",Th,vec(b),order=order0,dataname="b");
	savevtk(DIRres+"Br.vtu",Th,vec(Br),order=order0,dataname="br");
	savevtk(DIRres+"M.vtu",Th,vec2(m),order=order0,dataname="m");
	savevtk(DIRres+"H.vtu",Th,vec2(h),order=order0,dataname="h");
ENDIFMACRO

IFMACRO(DIM,2)
	// Exportando para o Octave
	real tr = (pi*rm)/p;
	real[int] xcoord(1001), Babs(1001), Brmx(1001), Brmy(1001);
	ofstream file1("Babs.txt");
	real zcoord = hest+hbob+hgap/2; //0.01515
	int i;// x vai de 0 até tr/2
	for (i=1; i<1001; i++){
		xcoord[i] = (tr/1000)*i;
		Babs[i] = sqrt(bx(xcoord[i],0.01515)^2+by(xcoord[i],0.01515)^2);
		Brmx[i] = bx(xcoord[i],0.01515);
		Brmy[i] = by(xcoord[i],0.01515);
		file1 << xcoord[i] << " " << Babs[i] << " " << Brmx[i] << " " << Brmy[i] << " " << endl;
	}
ENDIFMACRO

IFMACRO(DIM,3)
	real trad = (theta/2)*(pi/180);
	int imax = 20000;
	real ang;
	real[int] xcoord(imax), ycoord(imax), Babs(imax), Brmx(imax), Brmy(imax), Brmz(imax);
	real[int] Jdx(imax), Jdy(imax), Jdz(imax);
	real zcoord = hest+hbob+hgap/2;
	ofstream file1("b3D.txt");
	int i;
	for (i=1; i<imax; i++){
		xcoord[i] = rm*sin(i*(trad/(imax-1)));
		ycoord[i] = rm*cos(i*(trad/(imax-1)));
		ang = (180/pi)*(i)*(trad/(imax-1));
		Babs[i] = sqrt(bx(xcoord[i],ycoord[i],zcoord)^2+by(xcoord[i],ycoord[i],zcoord)^2+bz(xcoord[i],ycoord[i],zcoord)^2);
		Brmx[i] = bx(xcoord[i],ycoord[i],zcoord);
		Brmy[i] = by(xcoord[i],ycoord[i],zcoord);
		Brmz[i] = bz(xcoord[i],ycoord[i],zcoord);
		file1 << ang << " " << Babs[i] << " " << Brmx[i] << " " << Brmy[i] << " " << Brmz[i]  << endl;
	}
ENDIFMACRO
/*
IFMACRO(DIM,3)
	[tens2comp(tm0)] = [hx*bx,hy*by,hz*bz,0.5*(hy*bz+hz*by),0.5*(hx*bz+hz*bx),0.5*(hx*by+bx*hy)]-0.5*nu0*[bx*bx+by*by+bz*bz,bx*bx+by*by+bz*bz,bx*bx+by*by+bz*bz,0,0,0];
	[tens2comp(tm1)] = [tens2comp(tm0)]+[bx*mx,by*my,bz*mz,0.5*(by*mz+bz*my),0.5*(bx*mz+bz*mx),0.5*(bx*my+by*mx)];
	[tens2comp(tm2)] = [tens2comp(tm0)]-[bx*mx,by*my,bz*mz,0.5*(by*mz+bz*my),0.5*(bx*mz+bz*mx),0.5*(bx*my+by*mx)]+[mx*bx+my*by+mz*bz,mx*bx+my*by+mz*bz,mx*bx+my*by+mz*bz,0,0,0];
	[tens2comp(tm3)] = [tens2comp(tm0)]+[mx*bx+my*by+mz*bz,mx*bx+my*by+mz*bz,mx*bx+my*by+mz*bz,0,0,0];

ENDIFMACRO

int[int] regrotormag = [rotor[0],magnet[0],magnet[1]];

varf forcemag(vec(u),vec(uu)) =  intnd(Th)(-(regrotormag)*T2grads(tm0,uu));
ThP1vec vec(forct),vec(forctcyl);
forctx[]=forcemag(0,ThP1vec);
//FlagDofRegion(Th,P1,vec,regrotormag,usupportcoef,ima1P1vec)

int ncomp = (forctx.n/3);

real[int] compx(ncomp), compy(ncomp), compz(ncomp);
int ii = 0;
ofstream fileforc1("fileforctm0.txt");
for (int i=0; i<ncomp; i++){
//	compx[i] = flagdofregionima1P1vec[i+2*i]*forctx[][i+2*i];
	compx[i] = forctx[][i+2*i];
//	compy[i] = flagdofregionima1P1vec[i+2*i+1]*forctx[][i+2*i+1];
	compy[i] = forctx[][i+2*i+1];
//	compz[i] = flagdofregionima1P1vec[i+2*i+2]*forctx[][i+2*i+2];
	compz[i] = forctx[][i+2*i+2];
	fileforc1 << compx[i] << " " << compy[i] << " " << compz[i]  << endl;
}

real forcx = compx.sum;
real forcy = compy.sum;
real forcz = compz.sum;
real forcgima = sqrt(forcx^2+forcy^2+forcz^2);
cout << "coef = " << forcx << endl;
cout << "coef = " << forcy << endl;
cout << "coef = " << forcz << endl;
cout << "forcglob = " << forcgima << endl;

savevtk(DIRres+"forc"+Stringification(tm0)+".vtu",Th,[forctx,forcty,forctz],order=order1,dataname=Stringification(tm0));
int[int] regteste = [20302,20303,20304];
real surf=int2d(Th,regteste[0])(1);
real surf2=int2d(Th,regteste[1])(1);
real surf3=int2d(Th,regteste[2])(1);
cout << "tt = " << surf << endl;
cout << "tt = " << surf2 << endl;
cout << "tt = " << surf3 << endl; */

IFMACRO(DIM,2)
	[tens2comp(tm0)] = [hx*bx,hy*by,0.5*(hx*by+bx*hy)]-0.5*nu0*[bx*bx+by*by,bx*bx+by*by,0];
	[tens2comp(tm1)] = [tens2comp(tm0)]+[bx*mx,by*my,0.5*(bx*my+by*mx)];
	[tens2comp(tm2)] = [tens2comp(tm0)]-[bx*mx,by*my,0.5*(bx*my+by*mx)]+[mx*bx+my*by,mx*bx+my*by,0];
	[tens2comp(tm3)] = [tens2comp(tm0)]+[mx*bx+my*by,mx*bx+my*by,0];
ENDIFMACRO

IFMACRO(DIM,3)
	[tens2comp(tm0)] = [hx*bx,hy*by,hz*bz,0.5*(hy*bz+hz*by),0.5*(hx*bz+hz*bx),0.5*(hx*by+bx*hy)]-0.5*nu0*[bx*bx+by*by+bz*bz,bx*bx+by*by+bz*bz,bx*bx+by*by+bz*bz,0,0,0];
	[tens2comp(tm1)] = [tens2comp(tm0)]+[bx*mx,by*my,bz*mz,0.5*(by*mz+bz*my),0.5*(bx*mz+bz*mx),0.5*(bx*my+by*mx)];
	[tens2comp(tm2)] = [tens2comp(tm0)]-[bx*mx,by*my,bz*mz,0.5*(by*mz+bz*my),0.5*(bx*mz+bz*mx),0.5*(bx*my+by*mx)]+[mx*bx+my*by+mz*bz,mx*bx+my*by+mz*bz,mx*bx+my*by+mz*bz,0,0,0];
	[tens2comp(tm3)] = [tens2comp(tm0)]+[mx*bx+my*by+mz*bz,mx*bx+my*by+mz*bz,mx*bx+my*by+mz*bz,0,0,0];

ENDIFMACRO


IFMACRO(DIM,2)
	varf nodesurface(vec(u),vec(uu)) =  intnd(Th)(uux+uuy);
	ThP1vec vec(nodesurf);
	nodesurfx[]=nodesurface(0,ThP1vec);
	macro forcnod(rotor,magnet,t0)
	varf forcemag(vec(u),vec(uu)) =  intnd(Th)(-T2grads(tm2,uu));
	ThP1vec vec(forct);
	forctx[]=forcemag(0,ThP1vec);
	savevtk(DIRres+"forc"+Stringification(t0)+".vtu",Th#rotor#magnet,[forctx,forcty,0],order=order1,dataname=Stringification(t0));
	savevtk(DIRres+"nodesurf"+Stringification(t0)+".vtu",Th#rotor#magnet,[nodesurfx,nodesurfy,0],order=order1,dataname=Stringification(nodesurf));
	forctx[]./=nodesurfx[];
	savevtk(DIRres+"densforc"+Stringification(t0)+".vtu",Th#rotor#magnet,[forctx,forcty,0],order=order1,dataname=Stringification(denst0));
	//
ENDIFMACRO

IFMACRO(DIM,3)
	macro R sqrt(x*x+y*y) //

	varf nodevol(vec(u),vec(uu)) =  intnd(Th)(uux+uuy+uuz);
	ThP1vec vec(nodevol);
	nodevolx[]=nodevol(0,ThP1vec);

	macro forcnod(rotor,magnet,t0)
	varf forcemag(vec(u),vec(uu)) =  intnd(Th)(-T2grads(tm2,uu));
	ThP1vec vec(forct);
	forctx[]=forcemag(0,ThP1vec);
	savevtk(DIRres+"forc"+Stringification(t0)+".vtu",Th#rotor#magnet,[forctx,forcty,forctz],order=order1,dataname=Stringification(t0));
	savevtk(DIRres+"nodevol"+Stringification(t0)+".vtu",Th#rotor#magnet,[nodevolx,nodevoly,nodevolz],order=order1,dataname=Stringification(nodevol));
	forctx[]./=nodevolx[];
	savevtk(DIRres+"densforc"+Stringification(t0)+".vtu",Th#rotor#magnet,[forctx,forcty,forctz],order=order1,dataname=Stringification(denst0));

	FEspace(Th23,P0,vec);
	Th23P0vec vec(b3)=vec(b),vec(b3cyl);
	savevtk(DIRres+"B3.vtu",Th23,vec(b3),order=order0,dataname="b3");

	Th23P0vec vec(ur),vec(ut),vec(uz);
	vec(ur)=[x/R,y/R,0];
	vec(ut)=[-y/R,x/R,0];
	vec(uz)=[0,0,1];

	vec(b3cyl)=[vec(-b3)'*vec(ut),vec(-b3)'*vec(uz),vec(b3)'*vec(ur)]; /*manual sign change*/
	FEspace(Th23d,P0,vec);
	Th23dP0vec vec(b23d);
	b23dx[]=b3cylx[];
	savevtk(DIRres+"B23d.vtu",Th23d,[b23dx,b23dy,b23dz],order=order0,dataname="b23d");

	Th23P0vec vec(f3)=vec(forct),vec(f3cyl);
	savevtk(DIRres+"f3.vtu",Th23,vec(f3),order=order0,dataname="f3");

	vec(f3cyl)=[vec(-f3)'*vec(ut),vec(-f3)'*vec(uz),vec(f3)'*vec(ur)]; /*manual sign change*/
	Th23dP0vec vec(f23d);
	f23dx[]=f3cylx[];
	savevtk(DIRres+"f23d.vtu",Th23d,[f23dx,f23dy,f23dz],order=order0,dataname="f23d");

	//
ENDIFMACRO

forcnod(,,tm2); // Choose between (rotor,magnet) or (stator,coil)



//
//int ncomp = (forctx.n/3);
//
//int[int] regsupmag = [stator[0]];
//FlagDofRegion(Th,P1,vec,regsupmag,usupportcoef,supmagP1vec);
//
//real[int] compx(ncomp), compy(ncomp), compz(ncomp);
//int ii = 0;
//ofstream fileforc1("fileforctm3.txt");
//for (int i=0; i<ncomp; i++){
//	compx[i] = flagdofregionrotormagnetP1vec[i+2*i]*forctx[][i+2*i];
//	compy[i] = flagdofregionrotormagnetP1vec[i+2*i+1]*forctx[][i+2*i+1];
//	compz[i] = flagdofregionrotormagnetP1vec[i+2*i+2]*forctx[][i+2*i+2];
//	//compx[i] = forctx[][i+2*i];
//	//compy[i] = forctx[][i+2*i+1];
//	//compz[i] = forctx[][i+2*i+2];
//	fileforc1 << compx[i] << " " << compy[i] << " " << compz[i]  << endl;
//}
//
//real forcx = compx.sum;
//real forcy = compy.sum;
//real forcz = compz.sum;
//real forcgima = sqrt(forcx^2+forcy^2+forcz^2);
//cout << "coef = " << forcx << endl;
//cout << "coef = " << forcy << endl;
//cout << "coef = " << forcz << endl;
//cout << "forcglob = " << forcgima << endl;
//
