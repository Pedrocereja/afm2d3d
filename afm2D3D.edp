include "FETOOLS.edp"
include "REDSYS.edp"
include "ARRAYS.edp"

load "gmsh"
load "iovtk"
load "medit"
load "msh3"

macro DIM 2 // /* 2=2D , 3=3D */
macro COMP2D3D 0 // /* Nodal force comparision between 2D and 3D case, 1 if true */
macro ELAST 1 // /* Set 1 to perform the elasticity simulation */

bool bcheckboundaries=false; // set to "true" to check the boundary regions
bool bplotregion=false; // set to "true" to plot the physical regions
bool bplotcoils=false; // set to "true" to plot the mesh associated with each coil (3D) or the current density associated to each coil (2D)
bool bperiodicity=true; // set to "true" to apply periodicity condition
bool bcheckperiodicitydofs = false; // set to "true" to check the periodicity dofs
bool bchecksupport=true;
bool bcomputeinterp=1;

real Itot = 474.67; // total current in coils section (A) (in the considered configuration, phase U (or 0) has null current, and phase V (or 1) and W (or 2) carry the same current (up to the sign))
real Jimp = 7.8e5; // Imposed current density
real I1=Itot;

real Br = 1.17; // remanent induction of the magnets (T)

real mu0 = 4*pi*1e-7; //vacuum permeability
real nu0 = 1./mu0; // vacuum reluctivity
real muiron = 1000*mu0; // iron permeablitiy
real nuiron = 1./muiron; // iron reluctivity
real mupm = 1.05*mu0; // permanent magnet permeability
real nupm = 1./mupm; // permanent magnet reluctivity
real mucoil = mu0; // coil permeability
real nucoil = 1./mucoil; // coil reluctivity

IFMACRO(DIM,2)
	include "afm2D.def"
	include "afm2D.init"
	include "../include/MACROS2D.edp"
	// directory where the results should be saved
	string DIRres="results/2D/";

	mesh Th = gmshload("malhas/afm2D2.msh");
	plot(Th,wait=1);

	bool bplanestress=0;// true if plane stress, false if plane strain

	mesh Thper=movemesh(Th,[x+2*(3.14*rm)/p,y]); // Malha perpendicular à original (lado direito)
	plot(Th,Thper,wait=1);

	real[string] signcurrent;
	signcurrent["plus"]=1;
	signcurrent["minus"]=-1;

	macro currentdensity(A,plus,bplot)
	/* macro currentdensity(A,plus,bplot) compute current density field for phase "A plus"*/
	ThP0vec1 J#plus#A;
	{
	real surf=int2d(Th,phase#plus#[A])(1);
	J#plus#A=regphase#plus#[A]*signcurrent[Stringification(plus)]/surf;
	/*J#plus#A=regphase#plus#[A]*signcurrent[Stringification(plus)];*/
	if(bplot) plot(J#plus#A,wait=1,fill=1,value=1,cmm="J"+Stringification(plus)+Stringification(A)+" (A/m2)");
	}

	// surface regions
	int nbnd=5;
	int[int][int] bnd(nbnd);
	string[int] bndname(nbnd);
	int ibnd=0;
	//symmetry plane (mid plane of the stator, perpendicular to the axis of the machine)
	bnd[ibnd] = [ESTATORL1];
	bndname[ibnd]="szmin";
	// external plane boundary pependicular to the machine axis
	ibnd++;
	bnd[ibnd] = [CAMSARS];
	bndname[ibnd]="szmax";
	// periodicity planes (parallel to and containing the axis of the machine)
	ibnd++;
	bnd[ibnd] = [ESTATORL2,WML16,GAP1L23,GAP23L35,ROTORL41,CAMSARLD];
	bndname[ibnd]="sperio1";
	ibnd++;
	bnd[ibnd] = [ESTATORL3,VPL10,GAP1L24,GAP21L30,ROTORL42,CAMSARLE];
	bndname[ibnd]="sperio2";

	ibnd++;
	bnd[ibnd] = [ROTORL43];
	bndname[ibnd] = "rotrmbnd";

	int[string] ibndname; //to get the boundary index by name
	for(int i=0;i<nbnd;++i) ibndname[bndname[i]]=i;

	// boundary Dirichlet
	int[int] sBn0 = [bnd[ibndname["szmin"]]];
	sBn0=[sBn0,bnd[ibndname["szmax"]]];
 	int[int] sBn02 = bnd[ibndname["rotrmbnd"]];
 	
	//volume regions
	int[int][int] rotor(1), magnet(2),stator(1),air(1);
	rotor[0]=[ROTOR];
	magnet[0]=[IMA1];magnet[1]=[IMA2];
	stator[0]=[ESTATOR];

	air[0]=[GAP1,GAP21,GAP22,GAP23,CAMSAR]; //2D mesh

	int[int][int] phaseplus(3),coil(6);
	phaseplus[0]=[UPLUS];
	phaseplus[1]=[VPLUS];
	phaseplus[2]=[WPLUS];

	int[int][int] phaseminus(3);
	phaseminus[0]=[UMINUS];
	phaseminus[1]=[VMINUS];
	phaseminus[2]=[WMINUS];

	coil[0]=[UPLUS];
	coil[1]=[VPLUS];
	coil[2]=[WPLUS];
	coil[3]=[UMINUS];
	coil[4]=[VMINUS];
	coil[5]=[WMINUS];

	macro vecBr [0,Br*(regmagnet[0]-regmagnet[1])] //

ENDIFMACRO

IFMACRO(DIM,3)
	include "afm3D.def"
	include "afm3D.init"
	include "../include/MACROS3D.edp"
	// directory where the results should be saved
	string DIRres="results/3D/";

	mesh3 Th = gmshload3("malhas/afm3Dv2.msh");
	plot(Th,wait=1);

	mesh Th2 = gmshload("malhas/afm2D2.msh");
	plot(Th2,wait=1);

	meshS Th23d = movemesh23(Th2, transfo=[x,y,0]);


	real ppi = 3.14;
	real tr = 2*(ppi*rm)/p;			// Comprimento do rotor no qual está colado o imã
	meshS Th23 = movemesh23(Th2, transfo=[0,x-tr/2,y]);
	Th23 = movemeshS(Th23, transfo=[-rm*sin(y/rm),rm*cos(y/rm),z]);
	plot(Th23,wait=1);
	plot(Th2,Th23,Th,wait=1);


	bool bplanestress=0;//false for 3D case

	real angle=pi/7;
	mesh3 Thper=movemesh(Th,[cos(angle)*x-sin(angle)*y,sin(angle)*x+cos(angle)*y,z]);
	plot(Th,Thper,wait=1);

	macro currentdensity(A,plus,bplot)
	/* macro currentdensity(A,plus,bplot) compute current density field for phase "A plus"*/
	ThP0vec1 vec(J#plus#A);
	{
	mesh3 Thtrunc = trunc(Th,reg#phase#plus[A]>0.5);
	if(bplot) plot(Thtrunc,wait=1,cmm="mesh for current density phase "+Stringification(A)+Stringification(plus));
	fespace ThtruncP1scal(Thtrunc,P1);
	ThtruncP1scal v, vv;
	solve laplace(v,vv)=int3d(Thtrunc)(grad(v)'*grad(vv))
	+ on(bnd[ibndname["sphase"+Stringification(plus)+"in"+Stringification(A)]],v=0)
	+ on(bnd[ibndname["sphase"+Stringification(plus)+"out"+Stringification(A)]],v=1);
	vec(J#plus#A)=[reg#phase#plus[A]*dx(v),reg#phase#plus[A]*dy(v),reg#phase#plus[A]*dz(v)];
	varf vonin(v,vv)=on(bnd[ibndname["sphase"+Stringification(plus)+"out"+Stringification(A)]],v=1);
	ThtruncP1scal onin;
	onin[]=vonin(0,ThtruncP1scal,tgv=1);
	real I=int3d(Thtrunc)(vec(J#plus#A)'*[dx(onin),dy(onin),dz(onin)]); /*compute total current in*/
	J#plus#A#x[]=J#plus#A#x[]/I; /*nomalized current density*/
	savevtk(DIRres+"J"+Stringification(plus)+Stringification(A)+".vtu",Th,vec(J#plus#A),order=order0,dataname="J"+Stringification(plus)+Stringification(A));
	fespace ThtruncP0vec(Thtrunc,[P0,P0,P0]);
	ThtruncP0vec vec(jj);
	vec(jj)=vec(J#plus#A);
	savevtk(DIRres+"jj"+Stringification(plus)+Stringification(A)+".vtu",Thtrunc,vec(jj),order=order0,dataname="jj"+Stringification(plus)+Stringification(A));
	}
	// EOM
	// surface regions
	int nbnd=19;
	int[int][int] bnd(nbnd);
	string[int] bndname(nbnd);
	int ibnd=0;

	// internal radius of the machine
	bnd[ibnd] = [20776,20777,20778,20779,20780,20781,20782,20783,20784,20785,20807,20808,20809,20810,20811,20812,20813,20814,20815,20816,20838,20839,20840,20841,20842,20843,20844,20845,20846,20847,20869,20870,20871,20872,20873,20874,20875,20876,20877,20878,20900,20901,20902,20903,20904,20905,20906,20907,20908,20909];
	bndname[ibnd]="srint";
	// external radius of the machine
	ibnd++;
	bnd[ibnd] = [20982,20983,20984,20985,20986,20987,20988,20989,20990,20991,21013,21014,21015,21016,21017,21018,21019,21020,21021,21022,21044,21045,21046,21047,21048,21049,21050,21051,21052,21053,21075,21076,21077,21078,21079,21080,21081,21082,21083,21084,21106,21107,21108,21109,21110,21111,21112,21113,21114,21115];
	bndname[ibnd]="srext";
	//symmetry plane (mid plane of the stator, perpendicular to the axis of the machine)
	ibnd++;
	bnd[ibnd] = [20021,20022,20023,20024,20025,20026,20027,20028,20029,20030,20126,20127,20128,20129,20130,20131,20132,20133,20134,20135,20188,20189,20190,20191,20192,20193,20194,20195,20196,20197,20930,20931,20932,20933,20934,20935,20936,20937,20938,20939,20755,20756,20757,20758,20759,20760,20761,20762,20763,20764];
	bndname[ibnd]="szmin";
	// external plane boundary pependicular to the machine axis
	ibnd++;
	bnd[ibnd] = [20693,20694,20695,20696,20697,20698,20699,20700,20701,20702,20662,20663,20664,20665,20666,20667,20668,20669,20670,20671,20631,20632,20633,20634,20635,20636,20637,20638,20639,20640,21085,21086,21087,21088,21089,21090,21091,21092,21093,21094,20910,20911,20912,20913,20914,20915,20916,20917,20918,20919];
	bndname[ibnd]="szmax";
	// periodicity planes (parallel to and containing the axis of the machine)
	ibnd++;
	bnd[ibnd] = [20950,20971,21002,21033,21064,21095,20041,20073,20094,20105,20156,20167,20208,20249,20290,20331,20372,20393,20415,20446,20477,20600,20589,20578,20712,20682,20651,20724,20765,20796,20827,20858,20889];
	bndname[ibnd]="sperio1";
	ibnd++;
	bnd[ibnd] = [20042,20083,20104,20115,20166,20177,20218,20259,20300,20341,20382,20403,20425,20456,20487,20960,20981,21012,21043,21074,21105,20588,20599,20610,20661,20692,20722,20734,20775,20806,20837,20868,20899];
	bndname[ibnd]="sperio2";

	ibnd++;
	bnd[ibnd] = [20426,20427,20428,20429,20430,20431,20432,20433,20434,20435];
	bndname[ibnd] = "rintrot";

	//in and out surfaces for each phase winding (plus and minus)
	int[int][int] mpio(4*3); //minus/plus in/out boundary region indexes for the 3 phases
	int ip=0;
	mpio[4*ip+0]=[20133];mpio[4*ip+1]=[20195];mpio[4*ip+2]=[20190];mpio[4*ip+3]=[20128];
	ip++;
	mpio[4*ip+0]=[20126,20127];mpio[4*ip+1]=[20188,20189];mpio[4*ip+2]=[20193,20194];mpio[4*ip+3]=[20131,20132];
	ip++;
	mpio[4*ip+0]=[20129,20130];mpio[4*ip+1]=[20191,20192];mpio[4*ip+2]=[20196,20197];mpio[4*ip+3]=[20134,20135];

	for(int ip=0; ip<3;++ip){
		ibnd++; bnd[ibnd] = [mpio[4*ip+0]]; bndname[ibnd]="sphaseminusin"+ip;
		ibnd++; bnd[ibnd] = [mpio[4*ip+1]]; bndname[ibnd]="sphaseminusout"+ip;
		ibnd++; bnd[ibnd] = [mpio[4*ip+2]]; bndname[ibnd]="sphaseplusin"+ip;
		ibnd++; bnd[ibnd] = [mpio[4*ip+3]]; bndname[ibnd]="sphaseplusout"+ip;
	}

	int[string] ibndname; //to get the boundary index by name
	for(int i=0;i<nbnd;++i) ibndname[bndname[i]]=i;

	// boundary Dirichlet
	int[int] sBn0=bnd[ibndname["srint"]];
	sBn0=[sBn0,bnd[ibndname["srext"]]];
	sBn0=[sBn0,bnd[ibndname["szmin"]]];
	sBn0=[sBn0,bnd[ibndname["szmax"]]];

	int[int] sBn02 = bnd[ibndname["rintrot"]];
	//volume regions
	int[int][int] rotor(1), magnet(2),stator(1),air(1);
	rotor[0]=[ROTOR];
	magnet[0]=[IMA1];magnet[1]=[IMA2];
	stator[0]=[ESTATOR];

	air[0]=[ARARCRI,ARARCRE,AR1,AR31,AR32,AR21,AR22,AR23,ARSUP,ARRI1,ARRE1]; //3D mesh

	int[int][int] phaseplus(3);
	phaseplus[0]=[FASEUP];
	phaseplus[1]=[FASEVP];
	phaseplus[2]=[FASEWP];

	int[int][int] phaseminus(3);
	phaseminus[0]=[FASEUM];
	phaseminus[1]=[FASEVM];
	phaseminus[2]=[FASEWM];

	int[int][int] coil(6);
	coil[0] = [FASEUP];
	coil[1] = [FASEVP];
	coil[2] = [FASEWP];
	coil[3] = [FASEUM];
	coil[4] = [FASEVM];
	coil[5] = [FASEWM];

	macro vecBr [0,0,Br*(regmagnet[0]-regmagnet[1])] //
ENDIFMACRO

real[int] usupportcoef=vecff(1,1,1);
real[int] udircoef=vecff(1,1,1);

int[int] order0=[0]; // for cell based fields (savevtk interpolates at the center of the tetrahedron)
int[int] order1=[1]; // for node based fields (savevtk interpolates at nodes)

FEspace(Th,fetype1,vec1)
FEspace(Th,P1,scal)
FEspace(Th,P1,vec);

FEspace(Th,P0,scal)
FEspace(Th,P0,vec1)
FEspace(Th,P0,vec2)
FEspace(Th,P0,tens2);
FEspace(Th,P0,tens22);

FEspace(Thper,P1,scal)
FEspace(Thper,fetype1,vec1);
FEspace(Thper,P1,vec);


if(bcheckboundaries)
	for(int i=0;i<nbnd;++i)
	{
	varf vonbnd(a,aa)=on(bnd[i],a=1);
	ThP1scal bndP1scal;
	bndP1scal[] = vonbnd(0,ThP1scal, tgv=1);
	plot(bndP1scal,fill=1,value=1,wait=1,cmm="boundary "+bndname[i]);
	}

SetRegion(Th,rotor,bplotregion);
SetRegion(Th,magnet,bplotregion);
SetRegion(Th,stator,bplotregion);
SetRegion(Th,air,bplotregion);

SetRegion(Th,phaseplus,bplotregion);
SetRegion(Th,phaseminus,bplotregion);
SetRegion(Th,coil,bplotregion);

ThP0scal lambda,mu; //Lame coefficients (elastic properties of materials)
ThP1vec vec(u),vec(uu),vec(f),vec(udir);// vector fiels for the displacement, the force density ...
ThP0tens2 tens2(epsilon),tens2(sigma1); //elastic strain and stress
ThP0tens2 tens2(tm0); // Maxwell stress tensor without magnetostriction
ThP0tens2 tens2(tm1); // Maxwell stress tensor with constant material line circulation of M
ThP0tens2 tens2(tm2); // Maxwell stress tensor with constant material surface flux of M
ThP0tens2 tens2(tm3); // Maxwell stress tensor with constant magnetic moment

ThP0tens22 tens22(C); //stiffness tensor

ThP0vec2 vec(Br);
vec2(Br) = vecBr;

ThP0scal nu = nuiron*(regstator[0]+regrotor[0])+nupm*(regmagnet[0]+regmagnet[1])+nu0*regair[0]
              +nucoil*(regphaseplus[0]+regphaseplus[1]+regphaseplus[2]
                     + regphaseminus[0]+regphaseminus[1]+regphaseminus[2]);
mu = muiron*(regstator[0]+regrotor[0])+mupm*(regmagnet[0]+regmagnet[1])+mu0*regair[0]
              +mucoil*(regphaseplus[0]+regphaseplus[1]+regphaseplus[2]
                     + regphaseminus[0]+regphaseminus[1]+regphaseminus[2]);

currentdensity(0,minus,bplotcoils)
currentdensity(0,plus,bplotcoils)
currentdensity(1,minus,bplotcoils)
currentdensity(1,plus,bplotcoils)
currentdensity(2,minus,bplotcoils)
currentdensity(2,plus,bplotcoils)

ThP0vec1 vec1(JJ)=vec1(I1*Jplus0)+vec1(I1*Jminus0)+vec1(I1*Jplus1)+vec1(I1*Jminus1);

varf vonsperio2(u,uu)=on(bnd[ibndname["sperio2"]],u=1);
ThperP1scal onsperio2;
onsperio2[]=vonsperio2(0,ThperP1scal,tgv=1);
meshnd Thtrunc= trunc(Thper,onsperio2>0);
plot(Th,Thtrunc,wait=1,cmm="Th and trunc mesh");

FEspace(Thtrunc,fetype1,vec1)
//FEspace(Thtrunc,P1,vec);

matrix M;
cout << "compute interpolation matrix..." << endl;
cout<< "interp 1" << endl;
matrix M1=interpolate(Thtruncfetype1vec1,Thperfetype1vec1,inside=true,t=true);
real threshold=0.5;
CleanSparseMatrix(M1,threshold);
cout<< "interp 2" << endl;
matrix M2=interpolate(Thtruncfetype1vec1,Thfetype1vec1,inside=true);
CleanSparseMatrix(M2,threshold);
cout<< "end interp" << endl;
M = M1*M2;
CleanSparseMatrix(M,threshold);

real[int] fetype1vec1dircoef=vecff(1,1,1);
FlagDofBoundary(Th,fetype1,vec1,sBn0,fetype1vec1dircoef,Bn0)

SubFEspace(real,Th,fetype1,vec1,magstat)
AddDirichlet(Th,fetype1,vec1,magstat,flagdofboundaryBn0)
Thfetype1vec1 vec1(adir);
vec1firstcomp(adir)[](:)=0; //define a value for each dof invovled in the Dirichlet boundary conditions
SetDirichletValue(real,Th,fetype1,vec1,magstat,vec1firstcomp(adir)[])
SetDirichletFlag(real,Th,fetype1,vec1,magstat)

Thfetype1vec1 vec1(a);
varf magstat(vec1(a),vec1(aa)) = intnd(Th)(nu*rot2(a)'*rot2(aa))
										- intnd(Th)(vec1(JJ)'*vec1(aa))
										- intnd(Th)(nu*vec2(Br)'*rot2(aa))
										;

if(1)
{

cout << "build finite element system" << endl;
matrix AA=magstat(Thfetype1vec1,Thfetype1vec1); //Matriz AA somente para a malha TH
real[int] BB=magstat(0,Thfetype1vec1);
BB = -BB;
cout << "end build finite element system" << endl; // Matriz BB somente para a malha Th - Termo fonte

if(bperiodicity)
{
int[int,int] flagiso0(M.n,1);// be careful with tables [int,int], they must be fully initialized manually
 // the definition of "iso dofs" must be a table of type int[int,int]
 // here, there is no "iso dofs" condition, but we must define a minimum table with an "iso dofs" condition aplied to only one dof
flagiso0(:,0)=0;
flagiso0(0,0)=1;

real[int] connectcoef(M.n);
connectcoef(:)=1;

cout << "build extension matrix" << endl;
ExtensionMatrix2(real, flagiso0, M, connectcoef,Thfetype1vec1magstatdirflag,magstat)
//ExtensionMatrix(real, flagiso0, M, connectcoef,magstat)
cout << "end build extension matrix" << endl;

cout << "build restricted (iso and periodicity) and reduced (Dirichlet and support) system" << endl;
matrix Atemp1=AA*MatExtmagstat;
matrix AArest=MatExtmagstat'*Atemp1; //restricted matrix
real[int] BBrest=MatExtmagstat'*BB; //restricted RHS

real[int] restdir=MatExtmagstat'*Thfetype1vec1magstatdirflag; // restricted flag for Dirichlet condition
int[int] intrestdir(restdir.n);
for(int i=0;i<restdir.n;++i) if(abs(restdir(i))>0.5) intrestdir(i)=1; else intrestdir(i)=0; /*here node element have all the same orientation, for other type of element, even for a periodic mesh, we may note have the same orientation =>  use abs(). the abs() is also necessary when anti-periodicity is considered (connectcoef=-1)*/
/*the technique may not work for non-periodic meshes where the interpolation involves various elements...*/
real[int] restdirvalue=MatExtmagstat'*Thfetype1vec1magstatdirvalue; // restricted value for Dirichlet condition

RedSysDirichlet(real, AArest, BBrest, intrestdir, intrestdir, restdirvalue)
/*RedSysDirichlet creates the reduced system */

real[int] solper1(BBrestred.n);
set(AArestred,solver=CG);
//set(AArestred,solver=UMFPACK);

cout << " end build restricted (iso and periodicity) and reduced (Dirichlet and support) system" << endl;

cout <<"solve restricted and reduced system" << endl;
solper1=AArestred^-1*BBrestred;
cout <<"end solve restricted and reduced system" << endl;

cout <<"span restricted and reduced system solution to original system" << endl;
real[int] solper2(BBrest.n);
solper2=solper1(AArestspandof); //span the solution to the original system

real[int] tempsoldir(AArestinddirdof.n);
tempsoldir=restdirvalue(AArestinddirdof);
solper2(AArestinddirdof)=tempsoldir; // corrects the values on the Dirichlet dofs

vec1firstcomp(a)[]=MatExtmagstat*solper2; //extends the solution to the original problem
cout <<"span restricted and reduced system solution to original system" << endl;

}else{

RedSysDirichlet(real, AA, BB, Thfetype1vec1magstatdirflag, Thfetype1vec1magstatdirflag, Thfetype1vec1magstatdirvalue)
real[int] xx(AAred.n);
set(AAred,solver=CG);
//set(AAred,solver=UMFPACK);
xx=AAred^-1*BBred; //resolution of the reduced system
vec1firstcomp(a)[]=xx(AAspandof); // span the solution to the original system (be careful, the Dirichlet dofs are assigned the value of xx(0))

real[int] tempsoldir(AAinddirdof.n);
tempsoldir=Thfetype1vec1magstatdirvalue(AAinddirdof);
vec1firstcomp(a)[](AAinddirdof)=tempsoldir; // corrects the values on the Dirichlet dofs

}
}

ThP0vec2 vec2(b),vec2(h),vec2(m);
vec2(b)=rot2(a);
vec2(h) = nu*(vec2(b)-vec2(Br));
vec2(m) = nu0*(vec2(Br));

IFMACRO(DIM,2)
	savevtk(DIRres+"A.vtu",Th,a,order=order1,dataname="a");
	savevtk(DIRres+"B.vtu",Th,[bx,by,0],order=order0,dataname="b");
	savevtk(DIRres+"M.vtu",Th,[hx,hy,0],order=order0,dataname="m");
	savevtk(DIRres+"H.vtu",Th,[mx,my,0],order=order0,dataname="h");

	plot(vec1(JJ),wait=1,value=1,fill=1,cmm="JJ");
	plot(vec(Br),wait=1,fill=1,value=1,cmm="Br");
	plot(vec(b),wait=1,fill=1,value=1,cmm="B");
	plot(vec(h),wait=1,fill=1,value=1,cmm="B");
	plot(vec(m),wait=1,fill=1,value=1,cmm="B");
ENDIFMACRO

IFMACRO(DIM,3)
	savevtk(DIRres+"JJ.vtu",Th,vec1(JJ),order=order0,dataname="J");
	savevtk(DIRres+"A.vtu",Th,vec(a),order=order1,dataname="a");
	savevtk(DIRres+"B.vtu",Th,vec(b),order=order0,dataname="b");
	savevtk(DIRres+"Br.vtu",Th,vec(Br),order=order0,dataname="br");
	savevtk(DIRres+"M.vtu",Th,vec2(m),order=order0,dataname="m");
	savevtk(DIRres+"H.vtu",Th,vec2(h),order=order0,dataname="h");
ENDIFMACRO

IFMACRO(DIM,2)
	// Exportando para o Octave
	real tr = (pi*rm)/p;
	real[int] xcoord(10001), Babs(10001), Brmx(10001), Brmy(10001);
	ofstream file1("Babs.txt");
	real zcoord = hest+hbob+hgap/2; //0.01515
	int i;// x vai de 0 até tr/2
	for (i=1; i<10001; i++){
		xcoord[i] = (tr/10000)*i;
		Babs[i] = sqrt(bx(xcoord[i],0.01515)^2+by(xcoord[i],0.01515)^2);
		Brmx[i] = bx(xcoord[i],0.01515);
		Brmy[i] = by(xcoord[i],0.01515);
		file1 << xcoord[i] << " " << Babs[i] << " " << Brmx[i] << " " << Brmy[i] << " " << endl;
	}
ENDIFMACRO

IFMACRO(DIM,3)
	real trad = (theta/2)*(pi/180);
	int imax = 20000;
	real ang;
	real[int] xcoord(imax), ycoord(imax), Babs(imax), Brmx(imax), Brmy(imax), Brmz(imax);
	real[int] Jdx(imax), Jdy(imax), Jdz(imax);
	real zcoord = hest+hbob+hgap/2;
	ofstream file1("b3D.txt");
	int i;
	for (i=1; i<imax; i++){
		xcoord[i] = rm*sin(i*(trad/(imax-1)));
		ycoord[i] = rm*cos(i*(trad/(imax-1)));
		ang = (180/pi)*(i)*(trad/(imax-1));
		Babs[i] = sqrt(bx(xcoord[i],ycoord[i],zcoord)^2+by(xcoord[i],ycoord[i],zcoord)^2+bz(xcoord[i],ycoord[i],zcoord)^2);
		Brmx[i] = bx(xcoord[i],ycoord[i],zcoord);
		Brmy[i] = by(xcoord[i],ycoord[i],zcoord);
		Brmz[i] = bz(xcoord[i],ycoord[i],zcoord);
		file1 << ang << " " << Babs[i] << " " << Brmx[i] << " " << Brmy[i] << " " << Brmz[i]  << endl;
	}
ENDIFMACRO

IFMACRO(DIM,2)
	tens2(tm0) = [hx*bx,hy*by,0.5*(hx*by+bx*hy)]-0.5*nu0*[bx*bx+by*by,bx*bx+by*by,0];
	tens2(tm1) = tens2(tm0)+[bx*mx,by*my,0.5*(bx*my+by*mx)];
	tens2(tm2) = tens2(tm0)-[bx*mx,by*my,0.5*(bx*my+by*mx)]+[mx*bx+my*by,mx*bx+my*by,0];
	tens2(tm3) = tens2(tm0)+[mx*bx+my*by,mx*bx+my*by,0];
ENDIFMACRO

IFMACRO(DIM,3)
	tens2(tm0) = [hx*bx,hy*by,hz*bz,0.5*(hy*bz+hz*by),0.5*(hx*bz+hz*bx),0.5*(hx*by+bx*hy)]-0.5*nu0*[bx*bx+by*by+bz*bz,bx*bx+by*by+bz*bz,bx*bx+by*by+bz*bz,0,0,0];
	tens2(tm1) = tens2(tm0)+[bx*mx,by*my,bz*mz,0.5*(by*mz+bz*my),0.5*(bx*mz+bz*mx),0.5*(bx*my+by*mx)];
	tens2(tm2) = tens2(tm0)-[bx*mx,by*my,bz*mz,0.5*(by*mz+bz*my),0.5*(bx*mz+bz*mx),0.5*(bx*my+by*mx)]+[mx*bx+my*by+mz*bz,mx*bx+my*by+mz*bz,mx*bx+my*by+mz*bz,0,0,0];
	tens2(tm3) = tens2(tm0)+[mx*bx+my*by+mz*bz,mx*bx+my*by+mz*bz,mx*bx+my*by+mz*bz,0,0,0];
ENDIFMACRO

IFMACRO(DIM,2)
	varf nodesurface(vec(u),vec(uu)) =  intnd(Th)(uux+uuy);
	ThP1vec vec(nodesurf);
	nodesurfx[]=nodesurface(0,ThP1vec);
	macro forcnod(rotor,magnet,t0)
	varf forcemag(vec(u),vec(uu)) =  intnd(Th)(-T2grads(tm2,uu));
	ThP1vec vec(forct);
	forctx[]=forcemag(0,ThP1vec);
	savevtk(DIRres+"forc"+Stringification(t0)+".vtu",Th#rotor#magnet,[forctx,forcty,0],order=order1,dataname=Stringification(t0));
	savevtk(DIRres+"nodesurf"+Stringification(t0)+".vtu",Th#rotor#magnet,[nodesurfx,nodesurfy,0],order=order1,dataname=Stringification(nodesurf));
	forctx[]./=nodesurfx[];
	savevtk(DIRres+"densforc"+Stringification(t0)+".vtu",Th#rotor#magnet,[forctx,forcty,0],order=order1,dataname=Stringification(denst0));
	//
	forcnod(,,tm2);

ENDIFMACRO


IFMACRO(COMP2D3D,1)

	macro R sqrt(x*x+y*y) //

	varf nodevol(vec(u),vec(uu)) =  intnd(Th)(uux+uuy+uuz);
	ThP1vec vec(nodevol);
	nodevolx[]=nodevol(0,ThP1vec);

	macro forcnod(rotor,magnet,t0)
	varf forcemag(vec(u),vec(uu)) =  intnd(Th)(-T2grads(tm2,uu));
	ThP1vec vec(forct);
	forctx[]=forcemag(0,ThP1vec);
	savevtk(DIRres+"forc"+Stringification(t0)+".vtu",Th#rotor#magnet,[forctx,forcty,forctz],order=order1,dataname=Stringification(t0));
	savevtk(DIRres+"nodevol"+Stringification(t0)+".vtu",Th#rotor#magnet,[nodevolx,nodevoly,nodevolz],order=order1,dataname=Stringification(nodevol));
	forctx[]./=nodevolx[];
	savevtk(DIRres+"densforc"+Stringification(t0)+".vtu",Th#rotor#magnet,[forctx,forcty,forctz],order=order1,dataname=Stringification(denst0));

	FEspace(Th23,P0,vec);
	Th23P0vec vec(b3)=vec(b),vec(b3cyl);
	savevtk(DIRres+"B3.vtu",Th23,vec(b3),order=order0,dataname="b3");

	Th23P0vec vec(ur),vec(ut),vec(uz);
	vec(ur)=[x/R,y/R,0];
	vec(ut)=[-y/R,x/R,0];
	vec(uz)=[0,0,1];

	vec(b3cyl)=[vec(-b3)'*vec(ut),vec(-b3)'*vec(uz),vec(b3)'*vec(ur)]; /*manual sign change*/
	FEspace(Th23d,P0,vec);
	Th23dP0vec vec(b23d);
	b23dx[]=b3cylx[];
	savevtk(DIRres+"B23d.vtu",Th23d,[b23dx,b23dy,b23dz],order=order0,dataname="b23d");

	Th23P0vec vec(f3)=vec(forct),vec(f3cyl);
	savevtk(DIRres+"f3.vtu",Th23,vec(f3),order=order0,dataname="f3");

	vec(f3cyl)=[vec(-f3)'*vec(ut),vec(-f3)'*vec(uz),vec(f3)'*vec(ur)]; /*manual sign change*/
	Th23dP0vec vec(f23d);
	f23dx[]=f3cylx[];
	savevtk(DIRres+"f23d.vtu",Th23d,[f23dx,f23dy,f23dz],order=order0,dataname="f23d");

	//
	forcnod(,,tm2);

ENDIFMACRO


// ELASTICITY

IFMACRO(ELAST,1)

FEspace(Thtrunc,P1,vec);

matrix MM;
cout << "compute interpolation matrix..." << endl;
cout<< "interp 1" << endl;
matrix M11=interpolate(ThtruncP1vec,ThperP1vec,inside=true,t=true);
CleanSparseMatrix(M11,threshold);
cout<< "interp 2" << endl;
matrix M22=interpolate(ThtruncP1vec,ThP1vec,inside=true);
CleanSparseMatrix(M22,threshold);
cout<< "end interp" << endl;
MM = M11*M22;
CleanSparseMatrix(MM,threshold);

if(bcheckperiodicitydofs)
{
ux[](:)=1;
ThperP1vec vec(uper);
uperx[]=MM*ux[];
ux[]=uperx[];
plotveccomp2(u,uper,"nodes involved in the connection (periodicity)");
}

macro support(Th,P0scal,rotor,magnet)

int[int] rotor#magnet(rotor.n);
for(int i=0;i<rotor.n;i++)
rotor#magnet = [rotor[i]];
for(int i=0;i<magnet.n;i++)
rotor#magnet = [rotor#magnet,magnet[i]];

Th#P0scal reg#rotor#magnet;
for(int i=0;i<rotor.n;i++)
reg#rotor#magnet = reg#rotor[i];
for(int i=0;i<magnet.n;i++)
reg#rotor#magnet = reg#rotor#magnet+reg#magnet[i];

FlagDofRegion(Th,P1,vec,rotor#magnet,usupportcoef,rotor#magnet#P1vec)
if(bchecksupport)
{
ThP1vec vec(dofsupport);
dofsupportx[]=Int2Real(flagdofregion#rotor#magnet#P1vec);
plotveccomp(dofsupport," ");
}

// EOM

support(Th,P0scal,rotor,magnet); // Choose between (rotor,magnet) or (stator,coil)

FlagDofBoundary(Th,P1,vec,sBn02,udircoef,rintP1vec)
if(bchecksupport)
{
ThP1vec vec(dofdir);
dofdirx[]=Int2Real(flagdofboundaryrintP1vec);
plotveccomp(dofdir," ");
}

macro support2(rotor,magnet)

SubFEspace(real,Th,P1,vec,elast)
AddDirichlet(Th,P1,vec,elast,flagdofboundaryrintP1vec)
int[int] notflagdofregion#rotor#magnet#P1vec(flagdofregion#rotor#magnet#P1vec.n);
notflagdofregion#rotor#magnet#P1vec(:)=1;
notflagdofregion#rotor#magnet#P1vec-=flagdofregion#rotor#magnet#P1vec;
AddDirichlet(Th,P1,vec,elast,notflagdofregion#rotor#magnet#P1vec)
// EOM

support2(rotor,magnet); // Choose between (rotor,magnet) or (stator,coil)

udirx[](:)=0; //define a value for each dof involved in the Dirichlet boundary conditions
SetDirichletValue(real,Th,P1,vec,elast,udirx[])
SetDirichletFlag(real,Th,P1,vec,elast)

if(bchecksupport)
{
ThP1vec vec(dofdir);
dofdirx[]=ThP1vecelastdirflag;
plotveccomp(dofdir," ");
}

macro defconstant(EYoung1,nuPoisson1,rotor,EYoung2,nuPoisson2,magnet)

for(int i=0;i<rotor.n;i++){
mu= (EYoung1/(2*(1+nuPoisson1)))*(reg#rotor[i]);
lambda = (EYoung1*nuPoisson1/((1+nuPoisson1)*(1-2*nuPoisson1)))*(reg#rotor[i]);}
for(int i=0;i<magnet.n;i++){
mu = mu+(EYoung1/(2*(1+nuPoisson1)))*(reg#magnet[i]);
lambda = lambda+(EYoung2*nuPoisson2/((1+nuPoisson2)*(1-2*nuPoisson2)))*(reg#magnet[i]);}

// EOM

real EYoungf=200e9; //typical value for Iron and magnet
real nuPoissonf=0.3; //typical value for Iron and magnet
real EYoungc=140e9; //typical value for copper
real nuPoissonc=0.35; //typical value for copper

defconstant(EYoungf,nuPoissonf,rotor,EYoungf,nuPoissonf,magnet);  // Choose between (rotor,magnet) or (stator,coil)

IsotropicStiffnessLame(C,lambda,mu);

macro varfelast(rotor,magnet)
varf elast(vec(u),vec(uu))=  intnd(Th)((reg#rotor#magnet)*gradsT22grads(u,C,uu))
                          + intnd(Th)((reg#rotor#magnet)*T2grads(tm0,uu))
				                   ;
// EOM

varfelast(rotor,magnet);  // Choose between (rotor,magnet) or (stator,coil)

cout << "build finite element system" << endl;
matrix AA=elast(ThP1vec,ThP1vec);
real[int] BB=elast(0,ThP1vec);
BB = -BB;
cout << "end build finite element system" << endl;

if(bperiodicity)
{
int[int,int] flagiso0(MM.n,1);// be careful with tables [int,int], they must be fully initialized manually
 // the definition of "iso dofs" must be a table of type int[int,int]
 // here, there is no "iso dofs" condition, but we must define a minimum table with an "iso dofs" condition aplied to only one dof
flagiso0(:,0)=0;
flagiso0(0,0)=1;

real[int] connectcoef(MM.n);
connectcoef(:)=1;
cout << "build extension matrix" << endl;
ExtensionMatrix(real, flagiso0, MM, connectcoef,elast)
cout << "end build extension matrix" << endl;
/*
ExtensionMatrix MatExt:
MatExt.n=initial number of dofs, MatExt.m=reduced number of dofs (only master dofs)
the value of a dof v_i (master or slave) is sum_j(MatExt(i,j)*vrest_j) where vrest_j is the value of master dof j (index of a master dof in the restricted set of master dofs)
*/

if(0)
{
for(int i=0;i<masterindelast.n;++i)
{
  ThP1scal tempu;
	ux[](:)=0;
	ux[](masterindelast(i))=1;
	tempu=vec(u)'*vecff(1,2,3);
	plot(tempu,wait=1,fill=1,value=1,cmm="master (1=x,2=y,3=z)");
	real[int] temp(MatExtelast.m);
//	ux[]./=connectcoef;
	temp=MatExtelast'*ux[];
	ux[]=MatExtelast*temp;
	tempu=vec(u)'*vecff(1,2,3);
	plot(tempu,wait=1,fill=1,value=1,cmm="master & slave (1=x,2=y,3=z)");
}
}

cout << "build restricted (iso and periodicity) and reduced (Dirichlet and support) system" << endl;
matrix Atemp1=AA*MatExtelast;
matrix AArest=MatExtelast'*Atemp1; //restricted matrix
real[int] BBrest=MatExtelast'*BB; //restricted RHS

real[int] restdir=MatExtelast'*ThP1vecelastdirflag; // restricted flag for Dirichlet condition
int[int] intrestdir(restdir.n);
for(int i=0;i<restdir.n;++i) if(abs(restdir(i))>0.5) intrestdir(i)=1; else intrestdir(i)=0; /*here node element have all the same orientation, for other type of element, even for a periodic mesh, we may note have the same orientation =>  use abs(). the abs() is also necessary when anti-periodicity is considered (connectcoef=-1)*/
/*the technique may not work for non-periodic meshes where the interpolation involves various elements...*/
real[int] restdirvalue=MatExtelast'*ThP1vecelastdirvalue; // restricted value for Dirichlet condition

//real[int] restdir(masterindelast.n),restdirvalue(masterindelast.n);
//restdir=ThP1vecelastdirflag(masterindelast); // restricted flag for Dirichlet condition
//int[int] intrestdir(restdir.n);
//for(int i=0;i<restdir.n;++i) if(restdir(i)>0.5) intrestdir(i)=1; else intrestdir(i)=0;
//restdirvalue=ThP1vecelastdirvalue(masterindelast); // restricted value for Dirichlet condition

RedSysDirichlet(real, AArest, BBrest, intrestdir, intrestdir, restdirvalue)
/*RedSysDirichlet creates the reduced system */

real[int] solper1(BBrestred.n);
set(AArestred,solver=CG);

cout << " end build restricted (iso and periodicity) and reduced (Dirichlet and support) system" << endl;

cout <<"solve restricted and reduced system" << endl;
solper1=AArestred^-1*BBrestred;
cout <<"end solve restricted and reduced system" << endl;

cout <<"span restricted and reduced system solution to original system" << endl;
real[int] solper2(BBrest.n);
solper2=solper1(AArestspandof); //span the solution to the original system

real[int] tempsoldir(AArestinddirdof.n);
tempsoldir=restdirvalue(AArestinddirdof);
solper2(AArestinddirdof)=tempsoldir; // corrects the values on the Dirichlet dofs
ux[]=MatExtelast*solper2; //extends the solution to the original problem
cout <<"span restricted and reduced system solution to original system" << endl;

}else{
RedSysDirichlet(real, AA, BB, ThP1vecelastdirflag, ThP1vecelastdirflag, ThP1vecelastdirvalue)
real[int] xx(AA.n);
set(AAred,solver=CG);
xx=AAred^-1*BBred; //resolution of the reduced system
ThP1scal sol;
ux[]=xx(AAspandof); // span the solution to the original system (be careful, the Dirichlet dofs are assigned the value of xx(0))
}

plotveccomp(u,"solution")

tens2(sigma1) =  T22grads(C,u);

IFMACRO(DIM,2)

macro dirres(rotor,magnet,tm0)

mesh Th#rotor#magnet = trunc(Th,reg#rotor#magnet>0.5);
plot(Th#rotor#magnet,wait=1,cmm="reg"+Stringification(rotor#magnet));
DIRres="results/2D/"+Stringification(rotor)+Stringification(magnet)+"/";
savevtk(DIRres+"sigma"+Stringification(tm0)+".vtu",Th#rotor#magnet,tens2(sigma1),order=order0,dataname="sigma"+Stringification(tm0));

//

ENDIFMACRO

IFMACRO(DIM,3)

macro R sqrt(x*x+y*y) //
macro theta atan2(y,x) //

ThP1vec vec(ur),vec(ut),vec(uz);
vec(ur)=[x/R,y/R,0];
vec(ut)=[-y/R,x/R,0];
vec(uz)=[0,0,1];

ThP0tens2 tens2(sigcyl);
tens2(sigcyl)=T2inbasis(sigma1,ur,ut,uz);

macro dirres(rotor,magnet,tm0)

mesh3 Th#rotor#magnet = trunc(Th,reg#rotor#magnet>0.5);
plot(Th#rotor#magnet,wait=1,cmm="reg"+Stringification(rotor#magnet));
DIRres="results/3D/"+Stringification(rotor)+Stringification(magnet)+"/";
savevtk(DIRres+"sigma"+Stringification(tm0)+".vtu",Th#rotor#magnet,tens2(sigma1),order=order0,dataname="sigma"+Stringification(tm0));
savevtk(DIRres+"sigmacyl"+Stringification(tm0)+".vtu",Th#rotor#magnet,tens2(sigcyl),order=order0,dataname="sigmacyl"+Stringification(tm0));

//

ENDIFMACRO


dirres(rotor,magnet,tm0);  // Choose between (rotor,magnet) or (stator,coil)


ENDIFMACRO